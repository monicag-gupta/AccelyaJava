Spring is well-organized architecture consisting  of several modules. Modules in the Spring framework are:
Spring AOP, Aspects and Instrumentation: 
To allow users to implement custom aspects, complementing their use of OOP with AOP
These modules support aspect oriented programming implementation where you can use Advices, Pointcuts etc. to decouple the code.
The aspects module provides support to integration with AspectJ.
The instrumentation module provides support to class instrumentation and classloader implementations.
Spring ORM
The ORM package is related to the database access. It provides integration layers for JDO, Hibernate, iBatis, etc.
Spring DAO, Data Access / Integration
The DAO (Data Access Object) support in Spring is primarily for standardizing the data access work using JDBC, Hibernate or JDO.
This group comprises of JDBC, ORM, OXM, JMS and Transaction modules. These modules basically provide support to interact with the database.




Spring Context
This package builds on the beans package to add support for message sources and for the Observer design pattern, and the ability for application objects to obtain resources using a consistent API.
Spring Web
The Spring Web module is part of Spring’s web application development stack, which includes Spring MVC.
This group comprises of Web, Web-Servlet, Web-Struts and Web-Portlet. These modules provide support to create web application.
Spring Web MVC
This is the Module which provides the MVC implementations for the web applications.
Spring Test
This layer provides support of testing with JUnit and TestNG.
Spring Core
The Core package is the most important component of the Spring Framework. This component provides the Dependency Injection features. 
The BeanFactory  provides a factory pattern which separates the dependencies like initialization, creation and access of the objects from your actual program logic.



Inversion of Control is a principle in software engineering by which the control of objects or portions of a program is transferred to a container or framework. It’s most often used in the context of object-oriented programming.
IoC enables a framework to take control of the flow of a program and make calls to our custom code. 
To enable this, frameworks use abstractions with additional behavior built in. If we want to add our own behavior, we need to extend the classes of the framework or plugin our own classes.
The advantages of this architecture are:
decoupling the execution of a task from its implementation
making it easier to switch between different implementations
greater modularity of a program
greater ease in testing a program by isolating a component or mocking its dependencies and allowing components to communicate through contracts



IOC makes the code loosely coupled. In such cases, there is no need to modify the code if our logic is moved to new environment.
In Spring framework, IOC container is responsible to inject the dependency. 
We provide metadata to the IOC container either by XML file or annotation.
Advantage of Dependency Injection
makes the code loosely coupled so easy to maintain
makes the code easy to test



Spring Annotations List

@Component :       
It is generic  stereotype for any spring managed component.
@Repository :
Specialized form of @Component. This annotation work as marker for any class which fulfills the role of repository or Data Access  Object(Persistent Layer).
@Controller :
Specialized form of @Component and applied to Presentation Layer.
@Service :
Specialized form of @Component and applied to Service Layer.
@Configuration :
@Configuration annotated class is used to define beans.  Have methods with annotation @Bean
@Bean
It is a method level annotation which work with @Configuration
@Scope
Every bean defined in IoC container needs to have a scope, default scope is Singleton.
@DependsOn
The @DependsOn annotation can force Spring IoC container to initialize one or more beans before the bean which is annotated by @DependsOn annotation. The @DependsOn annotation may be used on any class directly or indirectly annotated with @Component or on methods annotated with @Bean .
@Primary
In Spring framework, the @Primary annotation is used to give higher preference to a bean, when there are multiple beans of same type. The @Primary annotation may be used on any class directly or indirectly annotated with @Component or on methods annotated with @Bean .
@Lazy
@Lazy annotation indicates whether a bean is to be lazily initialized. It can be used on @Component and @Bean definitions. A @Lazy bean is not initialized until referenced by another bean or explicitly retrieved from BeanFactory . Beans that are not annotated with @Lazy are initialized eagerly.
@Import
@Import annotation in Spring allows you to load bean definitions from one or more another @Configuration files or Components. You might not want to configure all the beans in one configuration file.
@ImportResource
@ImportResource annotation is used to load beans from an applicationContext.xml file into an Application Context.
@Value
@Value is a Java annotation that is used at the field or method/constructor parameter level and it indicates a default value for the affected argument. It is commonly used for injecting values into configuration variables
@Named 
@Named works the same as @Component. However, the annotations @Controller, @Service, and @Repository are more specific. A bean annotated with @Named annotation is considered as a component in spring container
@Inject 
@Inject is equivalent to spring @Autowired in spring container with some limitations. 
@PreDestroy and @PostConstruct
@PreDestroy and @PostConstruct are alternative way for bean initMethod and destroyMethod. It can be used when the bean class is defined by us.
@ComponentScan
Configures component scanning directives for use with @Configuration classes. Here we can specify the base packages to scan for spring components.
@PropertySource
Provides a simple declarative mechanism for adding a property source to Spring’s Environment. There is a similar annotation for adding an array of property source files i.e @PropertySources.
@Autowired
Spring @Autowired annotation is used for automatic injection of beans. Spring @Qualifier annotation is used in conjunction with Autowired to avoid confusion when we have two of more bean configured for same type
Spring MVC annotations:
@RequestMapping
@PathVariable
@RequestParam
@ModelAttribute
@RequestBody and @ResponseBody
@RequestHeader and @ResponseHeader
@CrossOrigin
@Transactional
Is the spring declarative transaction management annotation.
@EnableWebSecurity 
Is used with @Configuration class to have the Spring Security configuration defined
Spring Boot Annotations
@SpringBootApplication
@EnableAutoConfiguration





pom.xml:

<dependencies>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-core</artifactId>
			<version>${spring.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
			<version>${spring.version}</version>
		</dependency>
	</dependencies>
  <properties>
    <java.version>21</java.version>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
		<spring.version>6.1.5</spring.version>
	</properties>




Group id: com.springcore
Artifact Id: SpringPrj1


package com.springcore;

HelloWorld.java

package com.springcore;
public class HelloWorld {
private String message; //property
public void setMessage(String message){
this.message = message;
}
public void getMessage(){
System .out.println("Your Message : " + message);
}
}



MainApp.java

package com.springcore;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class MainApp {
public static void main(String[] args) {
ApplicationContext context =
new ClassPathXmlApplicationContext("Beans.xml");
HelloWorld obj = (HelloWorld) context.getBean("idhello");
obj.getMessage();
//context.close();
}
}




Beans.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://www.springframework.org/schema/beans
 http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
 		<bean id="idhello" class="com.springcore.HelloWorld">
 			<property name="message" value="Hello World!"/>
 		</bean>
</beans>













