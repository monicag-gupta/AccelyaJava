By default, assertions are disabled. We need to run the code as given. The syntax for enabling assertion statement in Java source code is:
java –ea Test
Or
java –enableassertions Test
Disabling Assertions
The syntax for disabling assertions in java are:
java –da Test
Or
java –disableassertions Test
Here, Test is the file name.







package aa;

public class Main {
	public static void main(String[] args) {
		System.out.println("Enter your Weight:");

		try (java.util.Scanner sc = new java.util.Scanner(System.in)) {
			int value = sc.nextInt();
			assert value >= 50 : " Underweight";
			System.out.println("value is " + value);
		}

	}
}







public class MainTestApp {
//@BeforeClass
	static {
		System.out.println("Before class Main");
	}

	public static void main(String[] a) {
		testsquare();// manual unit testing
	}

	static int square(int x) {
		return x * x;
	}

	static int cube(int x) {
		return x * x * x;
	}

//@test
	static void testsquare() { // unit test functions: test cases
		fn();
		int aa = 10;
		if (square(aa) == 110) {
			System.out.println("Test succedded");
		} else
			System.out.println("Test failed");
		fna();
	}

//@test
	static void testcube() {
//unit test functions: test cases
		fn();
		int aa = 10;
		if (cube(aa) == 1000) {
			System.out.println("Test succedded");
		} else
			System.out.println("Test failed");
		fna();
	}

//@Before
	static void fn() {
		System.out.println("before Test cases ");
	}

//@after
	static void fna() {
		System.out.println("After Test cases ");
	}
}






package aa;
public class MainTestApp {
//@BeforeClass
	static {
		System.out.println("Before class Main");
	}

	public static void main(String[] a) {
		testsquare();// manual unit testing
		testcube();
	}

	static int square(int x) {
		return x * x;
	}

	static int cube(int x) {
		return x * x * x;
	}

//@test
	static void testsquare() { // unit test functions: test cases
		fn();
		int aa = 10;
		if (square(aa) == 110) {
			System.out.println("Test succedded");
		} else
			System.err.println("Test failed");
		fna();
	}

//@test
	static void testcube() {
//unit test functions: test cases
		fn();
		int aa = 10;
		if (cube(aa) == 1000) {
			System.out.println("Test succedded");
		} else
			System.err.println("Test failed");
		fna();
	}

//@Before
	static void fn() {
		System.out.println("before Test cases ");
	}

//@after
	static void fna() {
		System.out.println("After Test cases ");
	}
}







The Junit 5.x framework is annotation based, so let's see the annotations that can be used while writing the test cases.
@Test annotation specifies that method is the test method.
@Test(timeout=1000) annotation specifies that method will be failed if it takes longer than 1000 milliseconds (1 second).
@BeforeClass annotation specifies that method will be invoked only once, before starting all the tests.
@Before annotation specifies that method will be invoked before each test.
@After annotation specifies that method will be invoked after each test.
@AfterClass annotation specifies that method will be invoked only once, after finishing all the tests.




The org.junit.Assert class provides methods to assert the program logic.
Methods of Assert class
void assertEquals(boolean expected,boolean actual): checks that two primitives/objects are equal. It is overloaded.
void assertTrue(boolean condition): checks that a condition is true.
void assertFalse(boolean condition): checks that a condition is false.
void assertNull(Object obj): checks that object is null.
void assertNotNull(Object obj): checks that object is not null.



Create a Java project : JUnitPrj
Add two packages:
	source 
	tests
Add the class file:
	source/MainClass.java
Add the JUnit Class file:
	tests/TestLogic.java
Add it as JUnit 4 Unit Test Cases
It will prompt to add the JUnit 5 library in the project. Add it.
	tests/TestCases.java
Add the codes
Run TestLogic as JUnit Tests
Run TestCases as JUnit Tests
Add Test Suite to the project
Add both the Tests there
 	Run it to get all tests Results together
Check the Result.
 


package source;
public class MainClass {
	public static int findMax(int arr[]) {
		int max = 0;
		// int max=arr[0];
		for (int i = 1; i < arr.length; i++) {
			if (max < arr[i])
				max = arr[i];
		}
		return max;
	}
	public static int cube(int n) {
		return n * n * n;
	}
}




package tests;
import source.*;
import static org.junit.Assert.*;
import org.junit.Test;

public class TestLogic {

	@Test
	public void test() {
		assertEquals(4,MainClass.findMax(new int[]{1,3,4,2}));

	}

}





package tests;

import static org.junit.Assert.*;
import org.junit.*;
import source.*;

public class TestCases {
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		System.out.println("before all tests");
	}

	@Before
	public void setUp() throws Exception {
		System.out.println("before each test");
	}

	@Test
	public void testFindMax() {
		System.out.println("test case1,2 find max");
		assertEquals(4, MainClass.findMax(new int[] { 1, 3, 4, 2 }));
		assertEquals(2, MainClass.findMax(new int[] { -12, -3, -4, 2 }));
	}

	@Test
	public void testCube() {
		System.out.println("test case cube");
		assertEquals(27, MainClass.cube(3));
	}

	@After
	public void tearDown() throws Exception {
		System.out.println("after each test");
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		System.out.println("after all tests");
	}
}









package tests;
import source.*;
import static org.junit.Assert.*;
import org.junit.Test;

public class TestLogic {

	@Test
	public void test() {
		assertEquals(-2,MainClass.findMax(new int[]{-7,-3,-4,-2}));

	}

}










package source;
public class MainClass {
	public static int findMax(int arr[]) {
//		int max = 0;
		 int max=arr[0];
		for (int i = 1; i < arr.length; i++) {
			if (max < arr[i])
				max = arr[i];
		}
		return max;
	}
	public static int cube(int n) {
		return n * n * n;
	}
}





Right click the project->New->other-> JUnit Test Suite
Next
Add the package: tests
Add the classes for test suite
Finish
The Suite is added




SpringBoot Tests:

Spring starter project:
Project: SpringBootTestPrj
Package: com.hello
Dependency: Spring Web

Create the model class as Employee.java in package com.hello.model
Create the Controller class as EmpController.java in com.hello.controller
Check: SpringBootTestPrjApplication
Code, Run and Check the Output
Create the Test class in src/test/java as SpringBootTestPrjApplicationTests.java in com.hello
Next extend the SpringBootTestPrjApplicationTests.java and write the test case for the EmpController as: TestWebApp.java
Run this TestWebApp class as a JUnit test case.



package com.hello;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringBootHelloWorldApplication {
	public static void main(String[] args) {
		SpringApplication.run(SpringBootHelloWorldApplication.class, args);
	}
}





package com.hello.model;
public class Employee {
	private String empId;
	private String name;
	private String designation;
	private double salary;
	public Employee() { }
	public String getName() {	return name;	}
	public void setName(String name) {	this.name = name;	}
	public String getDesignation() {		return designation;	}
	public void setDesignation(String designation) {		this.designation = designation;		}
	public double getSalary() {	return salary;		}
	public void setSalary(double salary) {	this.salary = salary;	}
	public String getEmpId() {	return empId;	}
	public void setEmpId(String empId) {	this.empId = empId;	}
}




package com.hello.controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import com.hello.model.Employee;
@RestController
public class EmpController {
	@GetMapping("/employee")
	public Employee firstPage() {
		Employee emp = new Employee();
		emp.setName("emp1");
		emp.setDesignation("manager");
		emp.setEmpId("1");
		emp.setSalary(3000);
		return emp;
	}
}



Compile and the run the SpringBootHelloWorldApplication.java as a Java application.
Go to localhost:8080/employee



Next we write JUnit test cases for the TestController.
Define the SpringBootHelloWorldTests.java as follows. 
Spring Boot provides a @SpringBootTest annotation which can be used as an alternative to the standard spring-test @ContextConfiguration annotation when you need Spring Boot features. 
The annotation works by creating the ApplicationContext used in your tests via SpringApplication.





package com.hello;

import com.hello.controller.EmpController;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.test.web.servlet.MockMvc;
import static org.hamcrest.Matchers.is;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest(EmpController.class)
public class TestWebApp {
    @Autowired
    private MockMvc mockMvc;

    @Test
    void testGetEmployee() throws Exception {
        mockMvc.perform(get("/employee"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.name", is("emp1")))
                .andExpect(jsonPath("$.designation", is("manager")))
                .andExpect(jsonPath("$.empId", is("1")))
                .andExpect(jsonPath("$.salary", is(3000.0)));
    }
}






ACTUATORS, METRICS AND HEALTH INDICATORS

Spring Boot Actuator is a sub-project of the Spring Boot Framework. It includes a number of additional features that help us to monitor and manage the Spring Boot application. It contains the actuator endpoints (the place where the resources live). We can use HTTP and JMX endpoints to manage and monitor the Spring Boot application. If we want to get production-ready features in an application, we should use the Spring Boot actuator.
There are three main features of Spring Boot Actuator:
Endpoint: 
The actuator endpoints allows us to monitor and interact with the application. Spring Boot provides a number of built-in endpoints. We can also create our own endpoint. We can enable and disable each endpoint individually. Most of the application choose HTTP, where the Id of the endpoint, along with the prefix of /actuator, is mapped to a URL.
For example, the /health endpoint provides the basic health information of an application. The actuator, by default, mapped it to /actuator/health.  
Metrics: 
Spring Boot Actuator provides dimensional metrics by integrating with the micrometer. The micrometer is integrated into Spring Boot. It is the instrumentation library powering the delivery of application metrics from Spring. It provides vendor-neutral interfaces for timers, gauges, counters, distribution summaries, and long task timers with a dimensional data model.
Audit: 
Spring Boot provides a flexible audit framework that publishes events to an AuditEventRepository. It automatically publishes the authentication events if spring-security is in execution.




Predefined Endpoints :1.x:

/auditevents lists security audit-related events such as user login/logout. Also, we can filter by principal or type among other fields.
/beans returns all available beans in our BeanFactory. Unlike /auditevents, it doesn’t support filtering.
/conditions, formerly known as /autoconfig, builds a report of conditions around autoconfiguration.
/configprops allows us to fetch all @ConfigurationProperties beans.
/env returns the current environment properties. Additionally, we can retrieve single properties.
/flyway provides details about our Flyway database migrations.
/health summarizes the health status of our application.
/heapdump builds and returns a heap dump from the JVM used by our application.
/info returns general information. It might be custom data, build information or details about the latest commit.
/liquibase behaves like /flyway but for Liquibase.
/logfile returns ordinary application logs.
/loggers enables us to query and modify the logging level of our application.
/metrics details metrics of our application. This might include generic metrics as well as custom ones.
/scheduledtasks provides details about every scheduled task within our application.
/sessions lists HTTP sessions, given we are using Spring Session.
/shutdown performs a graceful shutdown of the application.
/threaddump dumps the thread information of the underlying JVM.






Spring Boot actuator properties
management.security.enabled=true  
management.security.roles=ADMIN  
security.basic.enabled=true  
security.user.name=admin  
security.user.passowrd=admin 




Spring  Starter project.
Provide the Artifact Id : spring-boot-actuator-example
Provide the Group name: com.sb
Add the following dependencies: 
Spring Web 
Spring Boot Starter Actuator

Create a Controller class. 
	We have created the controller class with the name DemoRestController.

Run the Application: 


package com.sb;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class DemoRestController {
	@GetMapping("/hello")
	public String hello() {
		return "Hello User!";
	}
}


application.properties:

management.security.enabled=false




http://localhost:8080/actuator

http://localhost:8080/actuator/health



We can configure the group to show more details via application.properties:

management.security.enabled=false
management.endpoint.health.group.custom.show-components=always
management.endpoint.health.group.custom.show-details=always


http://localhost:8080/actuator/health



We need to add the following configuration to expose all endpoints:
management.endpoints.web.exposure.include=*
To explicitly enable a specific endpoint (e.g., /shutdown), we use:
management.endpoint.shutdown.enabled=true
To expose all enabled endpoints except one (e.g., /loggers), we use:
management.endpoints.web.exposure.include=*
management.endpoints.web.exposure.exclude=loggers


application.properties:

management.security.enabled=false
management.endpoint.health.group.custom.show-components=always
management.endpoint.health.group.custom.show-details=always
management.endpoints.web.exposure.include=*


http://localhost:8080/actuator/info
http://localhost:8080/actuator/metrics
http://localhost:8080/actuator/health
http://localhost:8080/actuator





