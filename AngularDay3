RxJS (Reactive Extensions for JavaScript) is a library for reactive programming using Observables.
Angular’s HttpClient returns Observables, making RxJS the core tool for handling REST API calls, async streams, and event handling.
An Observable is a way to handle asynchronous data streams.Think of it as a “data producer” that keeps sending values over time, and your code can subscribe to receive those values.
It’s part of RxJS (Reactive Extensions for JavaScript), and Angular uses it heavily.
Common RxJS Operators with REST
When calling REST APIs, you typically use these RxJS operators:
map → Transform response data.
catchError → Handle API errors.
tap → Perform side effects (like logging).
switchMap → Chain API calls (cancel previous one if new request fires).
mergeMap → Run multiple requests in parallel.
debounceTime → Delay requests (useful in search). 



In module.ts
Modules are IMPORTED
Services, pipes, directives, components are DECLARED
Services are PROVIDED
first component to be executed are BOOTSTRAPED
Declarations can be EXPORTED




Install dependencies
npm install rxjs
(RxJS comes with Angular, so you usually don’t need to install it separately.)
Import HttpClientModule
Add it in your app.module.ts:

import { HttpClientModule } from '@angular/common/http';

@NgModule({
  imports: [HttpClientModule],
})
export class AppModule {}




Example: REST API Service (GET, POST)
product.service.ts

// product.service.ts
import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError, map } from 'rxjs/operators';

export interface Product {
  id: number;
  title: string;
  price: number;
  image: string;
}

@Injectable({ providedIn: 'root' })
export class ProductService {
  private apiUrl = 'https://fakestoreapi.com/products';

  constructor(private http: HttpClient) {}

  // GET all products
  getProducts(): Observable<Product[]> {
    return this.http.get<Product[]>(this.apiUrl).pipe(
      map((data) => data), // transform if needed
      catchError(this.handleError)
    );
  }

  // POST new product
  addProduct(product: Product): Observable<Product> {
    return this.http.post<Product>(this.apiUrl, product).pipe(
      catchError(this.handleError)
    );
  }

  // Handle API errors
  private handleError(error: HttpErrorResponse) {
    console.error('API Error:', error.message);
    return throwError(() => new Error('Something went wrong!'));
  }
}



Explanation:

this.http.get<Product[]>(this.apiUrl)
Makes a GET request to this.apiUrl (e.g., https://fakestoreapi.com/products).
<Product[]> is a generic type that tells Angular: “I expect the response to be an array of Product objects.”
Because of this, data in the stream will already be typed as Product[].
.pipe(...)
pipe() lets you chain RxJS operators that transform or handle the observable stream.
map((data) => data)
map is an RxJS operator.
Here it’s not doing anything (just returning data as-is).
But you could transform the response if needed.Example: only return id and title:
map((data) => data.map(item => ({ id: item.id, title: item.title })))
catchError(this.handleError)
catchError lets you handle errors in the observable chain.
this.handleError should be a method in your service that takes the error and returns a new observable (usually throwError).



Using Service in a Component

app.component.ts


// app.component.ts
import { Component, OnInit } from '@angular/core';
import { ProductService, Product } from './product.service';

@Component({
  selector: 'app-root',
  template: `
    <h2>Product List</h2>
    <ul>
      <li *ngFor="let p of products">
        <br><br>
        <img src={{p.image}} alt="Bad Image URL" height="100" width="100"/><br>
        {{p | json}} <br><br>
         {{ p.title }} - {{ p.price }}
        <hr>
      </li>
    </ul>
  `
})
export class AppComponent implements OnInit {
  products: Product[] = [];

  constructor(private productService: ProductService) {}

  ngOnInit() {
    this.productService.getProducts().subscribe({
      next: (data) => (this.products = data),
      error: (err) => console.error(err)
    });
  }
}






The whole cycle
1. Component initializes → ngOnInit() runs.
2. Service method (getProducts) is called.
3. HTTP request is sent.
4. When response arrives:
If success → next runs → UI updates.
If failure → error runs → logs or shows error message.

Observable lifecycle
An Observable can emit:
Next → a new value/data is sent.
Error → something went wrong.
Complete → it’s done, no more values.



Where it runs
ngOnInit() is a lifecycle hook in Angular.
It’s the right place to fetch data from a service (like calling an API).
Step 1: Call the service : this.productService.getProducts()
This calls the method from your ProductService.
That method uses HttpClient to make an HTTP GET request to the API (e.g., https://fakestoreapi.com/products).
It returns an Observable<Product[]>.
Step 2: Subscribe to the Observable : .subscribe({...})
Observables are lazy → they don’t actually run until you subscribe.
By subscribing, you’re saying: “Execute this HTTP request and notify me when data arrives or if there’s an error.”
Step 3: Handle the success case : next: (data) => this.products = data
When the HTTP request succeeds, the API response (data) is passed here.
this.products = data; saves the fetched array of products into your component property.
This automatically updates the HTML template via Angular’s data binding.
Step 4: Handle the error case : error: (err) => console.error(err)
If the HTTP request fails (e.g., server down, wrong URL, no internet), this block runs.
Right now, it just logs the error in the browser console.
You could also show a user-friendly message, like “Failed to load products.”



Generate a Feature Module
  ng generate module items
This creates a folder src/app/items with:
  items.module.ts
Generate a Component inside Product Module
  ng generate component items/product-list
This creates:
product-list.component.ts
product-list.component.html
Added to items.module.ts automatically.




src/app/items/product-list/product-list.component.ts

import { Component } from '@angular/core';

@Component({
  selector: 'app-product-list',
  templateUrl: './product-list.component.html'
})
export class ProductListComponent {
  products = [
    { name: 'iPhone 16', price: 1299 },
    { name: 'Samsung Galaxy S25', price: 1199 },
    { name: 'Pixel 10', price: 899 }
  ];
}




src/app/items/product-list/product-list.component.html

<h2>Product List</h2>
<ul>
  <li *ngFor="let product of products">
    {{ product.name }} - ${{ product.price }}
  </li>
</ul>


src/app/items/items.module.ts

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ProductListComponent } from './product-list/product-list.component';

@NgModule({
  declarations: [ProductListComponent], // Component belongs to this module
  imports: [CommonModule],              // Provides ngFor, ngIf etc.
  exports: [ProductListComponent]       // Export to use in AppModule
})
export class ItemsModule { }




Import ProductModule in AppModulesrc/app/app.module.ts

import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';

import { AppComponent } from './app.component';
import { ItemsModule } from './items/items.module'; // import module

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule, ItemsModule],  // add here
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule {}



src/app/app.component.ts

// app.component.ts
import { Component, OnInit } from '@angular/core';
import { ProductService, Product } from './product.service';

@Component({
  selector: 'app-root',
  templateUrl:'./app.component.html'
})
export class AppComponent implements OnInit {
  products: Product[] = [];

  constructor(private productService: ProductService) {}

  ngOnInit() {
    this.productService.getProducts().subscribe({
      next: (data) => (this.products = data),
      error: (err) => console.error(err)
    });
  }
}




Use Product Component in AppComponentsrc/app/app.component.html

<app-product-list></app-product-list>





Example: JWT Authentication

cd..
ng new ng2app

ng generate component login
ng generate component dashboard
npm install rxjs


Create Auth Service

src/app/auth.service.ts


import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, tap } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class AuthService {
    private apiUrl = 'https://dummyjson.com/auth/login';
    private readonly TOKEN_KEY = 'token';
    constructor(private http: HttpClient) { }
    login(username: string, password: string): Observable<any> {
        return this.http.post<any>(this.apiUrl, { username, password })
            .pipe(tap(res => localStorage.setItem(this.TOKEN_KEY, res.token)));
    }
    logout() { localStorage.removeItem(this.TOKEN_KEY);  }
    isLoggedIn(): boolean { return !!localStorage.getItem(this.TOKEN_KEY);  }
    getToken(): string | null { return localStorage.getItem(this.TOKEN_KEY); }
}




https://dummyjson.com/users



@Injectable marks a class as available for dependency injection.
Without it, Angular cannot inject the service into components or other services.
Example:
@Injectable()
export class AuthService { }
Now Angular knows AuthService can be injected.

providedIn: 'root’ :
providedIn determines where the service is provided in the application’s dependency injector. 
'root' means:The service is singleton, shared across the entire app.



tap here logs the API response and stores the token, without changing the observable’s data.
tap = peek & perform side effects, but the data continues unchanged downstream.




Create Auth Guard
src/app/auth.guard.ts

import { Injectable } from '@angular/core';
import { CanActivate, Router } from '@angular/router';
import { AuthService } from './auth.service';

@Injectable({ providedIn: 'root' })
export class AuthGuard implements CanActivate {
  constructor(private auth: AuthService, private router: Router) {}

  canActivate(): boolean {
    if (this.auth.isLoggedIn()) return true;
    this.router.navigate(['/login']);
    return false;
  }
}






Create HTTP Interceptor

src/app/auth.interceptor.ts


import { Injectable } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler } from '@angular/common/http';
import { AuthService } from './auth.service';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  constructor(private auth: AuthService) {}

  intercept(req: HttpRequest<any>, next: HttpHandler) {
    const token = this.auth.getToken();
    if (token) {
      const cloned = req.clone({
        headers: req.headers.set('Authorization', `Bearer ${token}`)
      });
      return next.handle(cloned);
    }
    return next.handle(req);
  }
}





intercept(req: HttpRequest<any>, next: HttpHandler)
req: HttpRequest<any>
Represents the outgoing HTTP request.
HttpRequest is immutable, meaning you cannot modify it directly — you must clone it to make changes (like adding headers).
next: HttpHandler
Represents the next handler in the chain.
Calling next.handle(req) passes the request to the next interceptor or finally to the HTTP backend that sends the request to the server.
Intercepts all HTTP requests before they are sent.
Lets you:
Add headers (like JWT token)
Modify the request URL or body
Handle errors globally
Log requests
Returns an Observable, usually with next.handle(modifiedReq).



Flow:
Angular sends a request.
Interceptor captures it.
If token exists → clone and add header.
Pass it to next handler (next.handle).
Request goes to server.
Response flows back through the interceptor chain.


Immutable: Always use req.clone() to modify.
Chainable: Multiple interceptors can be used; they all call next.handle().
Observable: next.handle(req) returns an Observable you can pipe() to handle response/errors.
req.clone()
HttpRequest objects in Angular are immutable, meaning you cannot change them directly.
clone() creates a copy of the request with modified properties (like headers, body, URL, etc.).
This is required whenever you want to add something like an Authorization header.
req.headers.set('Authorization', Bearer ${token})
req.headers gives you access to the request headers.
.set() creates a new headers object with the Authorization header added (or replaced if it exists).
`Bearer ${token}` is the JWT token formatted as a Bearer token for authorization.
What this does together
Creates a new request identical to the original but with the JWT token attached in the headers.
cloned is then sent to the server:
return next.handle(cloned);






Update App Module

src/app/app.module.ts


import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { FormsModule } from '@angular/forms';
import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';

import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';
import { LoginComponent } from './login/login.component';
import { DashboardComponent } from './dashboard/dashboard.component';
import { AuthInterceptor } from './auth.interceptor';

@NgModule({
  declarations: [AppComponent, LoginComponent, DashboardComponent],
  imports: [BrowserModule, FormsModule, HttpClientModule, AppRoutingModule],
  providers: [
    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }
  ],
  bootstrap: [AppComponent]
})
export class AppModule {}




Setup Routing

src/app/app-routing.module.ts


import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { LoginComponent } from './login/login.component';
import { DashboardComponent } from './dashboard/dashboard.component';
import { AuthGuard } from './auth.guard';

const routes: Routes = [
  { path: '', redirectTo: '/login', pathMatch: 'full' },
  { path: 'login', component: LoginComponent },
  { path: 'dashboard', component: DashboardComponent, canActivate: [AuthGuard] }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule {}




Login Component

src/app/login/login.component.ts

import { Component } from '@angular/core';
import { Router } from '@angular/router';
import { AuthService } from '../auth.service';

@Component({
  selector: 'app-login',
  templateUrl: './login.component.html',
  styleUrls: ['./login.component.css']
})
export class LoginComponent {
  username = 'kminchelle'; // DummyJSON test user
  password = '0lelplR';    // DummyJSON password
  error = '';
  constructor(private auth: AuthService, private router: Router) {}
  login() {
    this.auth.login(this.username, this.password).subscribe({
      next: () => this.router.navigate(['/dashboard']),
      error: (err) => this.error = 'Login failed!'
    });
  }
}



Login Component
src/app/login/login.component.html

 <h2>Login</h2>
    <h4>emilys : emilyspass</h4>
    <form (ngSubmit)="login()">
      <input [(ngModel)]="username" name="username" placeholder="Username" required />
      <input [(ngModel)]="password" name="password" type="password" placeholder="Password" required />
      <button type="submit">Login</button>
    </form>
    <p *ngIf="error" style="color:red">{{ error }}</p>



Dashboard Component
src/app/dashboard/dashboard.component.ts

import { Component } from '@angular/core';
import { AuthService } from '../auth.service';
import { Router } from '@angular/router';

@Component({
  selector: 'app-dashboard',
  template: `
    <h2>Dashboard</h2>
    <p>Welcome! You are logged in.</p>
    <button (click)="logout()">Logout</button>
  `
})
export class DashboardComponent {
  constructor(private auth: AuthService, private router: Router) {}
  logout() {
    this.auth.logout();
    this.router.navigate(['/login']);
  }
}




Main App:
app.component.ts

import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html'
})
export class AppComponent {
  title = 'angular-jwt-demo';
}



Main App:

app.component.html

<h1>{{ title }}</h1>
<router-outlet></router-outlet>












































