RxJS (Reactive Extensions for JavaScript) is a library for reactive programming using Observables.
Angular’s HttpClient returns Observables, making RxJS the core tool for handling REST API calls, async streams, and event handling.
An Observable is a way to handle asynchronous data streams.Think of it as a “data producer” that keeps sending values over time, and your code can subscribe to receive those values.
It’s part of RxJS (Reactive Extensions for JavaScript), and Angular uses it heavily.
Common RxJS Operators with REST
When calling REST APIs, you typically use these RxJS operators:
map → Transform response data.
catchError → Handle API errors.
tap → Perform side effects (like logging).
switchMap → Chain API calls (cancel previous one if new request fires).
mergeMap → Run multiple requests in parallel.
debounceTime → Delay requests (useful in search). 



In module.ts
Modules are IMPORTED
Services, pipes, directives, components are DECLARED
Services are PROVIDED
first component to be executed are BOOTSTRAPED




Install dependencies
npm install rxjs
(RxJS comes with Angular, so you usually don’t need to install it separately.)
Import HttpClientModule
Add it in your app.module.ts:

import { HttpClientModule } from '@angular/common/http';

@NgModule({
  imports: [HttpClientModule],
})
export class AppModule {}




Example: REST API Service (GET, POST)
product.service.ts

// product.service.ts
import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError, map } from 'rxjs/operators';

export interface Product {
  id: number;
  title: string;
  price: number;
}

@Injectable({ providedIn: 'root' })
export class ProductService {
  private apiUrl = 'https://fakestoreapi.com/products';

  constructor(private http: HttpClient) {}

  // GET all products
  getProducts(): Observable<Product[]> {
    return this.http.get<Product[]>(this.apiUrl).pipe(
      map((data) => data), // transform if needed
      catchError(this.handleError)
    );
  }

  // POST new product
  addProduct(product: Product): Observable<Product> {
    return this.http.post<Product>(this.apiUrl, product).pipe(
      catchError(this.handleError)
    );
  }

  // Handle API errors
  private handleError(error: HttpErrorResponse) {
    console.error('API Error:', error.message);
    return throwError(() => new Error('Something went wrong!'));
  }
}


Explanation:

this.http.get<Product[]>(this.apiUrl)
Makes a GET request to this.apiUrl (e.g., https://fakestoreapi.com/products).
<Product[]> is a generic type that tells Angular: “I expect the response to be an array of Product objects.”
Because of this, data in the stream will already be typed as Product[].
.pipe(...)
pipe() lets you chain RxJS operators that transform or handle the observable stream.
map((data) => data)
map is an RxJS operator.
Here it’s not doing anything (just returning data as-is).
But you could transform the response if needed.Example: only return id and title:
map((data) => data.map(item => ({ id: item.id, title: item.title })))
catchError(this.handleError)
catchError lets you handle errors in the observable chain.
this.handleError should be a method in your service that takes the error and returns a new observable (usually throwError).



Using Service in a Component

app.component.ts








