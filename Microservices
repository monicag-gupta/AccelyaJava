Spring Cloud Config Server
Spring Cloud Config Server provides the HTTP resource-based API for external configuration in the distributed system. We can enable the Spring Cloud Config Server by using the annotation @EnableConfigServer.
Netflix Eureka Naming Server
Netflix Eureka Server is a discovery server. It provides the REST interface to the outside for communicating with it. A microservice after coming up, register itself as a discovery client. The Eureka server also has another software module called Eureka Client. Eureka client interacts with the Eureka server for service discovery. The Eureka client also balances the client requests.
Hystrix Server
Hystrix server acts as a fault-tolerance robust system. It is used to avoid complete failure of an application. It does this by using the Circuit Breaker mechanism. If the application is running without any issue, the circuit remains closed. If there is an error encountered in the application, the Hystrix Server opens the circuit. The Hystrix server stops the further request to calling service. It provides a highly robust system.
Netflix Zuul API Gateway Server
Netflix Zuul Server is a gateway server from where all the client request has passed through. It acts as a unified interface to a client. It also has an inbuilt load balancer to load the balance of all incoming request from the client.
Netflix Ribbon
Netflix Ribbon is the client-side Inter-Process Communication (IPC) library. It provides the client-side balancing algorithm. It uses a Round Robin Load Balancing: Load balancing, Fault tolerance, Multiple protocols(HTTP, TCP, UDP), Caching and Batching
Zipkin Distributed Server
Zipkin is an open-source project m project. That provides a mechanism for sending, receiving, and visualization traces.






Application
Port
Spring Cloud Config Server
8888
Netflix Eureka Naming Server
8761
Netflix Zuul API gateway Server
8765
Zipkin distributed Tracing Server
9411




SB Project:
limits-service

Group: com.example.demo
Package:
com.example.demo



Spring Web, Spring Boot DevTools, Spring Boot Actuator, Config Client, Cloud Bootstrap


application.properties:

spring.application.name=limits-service
spring.cloud.config.enabled=false



com.example.demo.controller
LimitsConfigurationController

package com.example.demo.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import  com.example.demo.bean.LimitConfiguration;
@RestController
public class LimitsConfigurationController {
	@GetMapping("/limits")
	public LimitConfiguration retriveLimitsFromConfigurations() {
		return new LimitConfiguration(1000, 1);
	}
}





com.example.demo.bean
LimitConfiguration

package com.example.demo.bean;

public class LimitConfiguration {
	private int maximum;
	private int minimum;
//no-argument constructor  
	protected LimitConfiguration() {
	}
//generating getters  
	public int getMaximum() {
		return maximum;
	}
	public int getMinimum() {
		return minimum;
	}
//genetrating constructor using fields  
	public LimitConfiguration(int maximum, int minimum) {
		super();
		this.maximum = maximum;
		this.minimum = minimum;
	}
}



com.example.demo
Configuration

package com.example.demo;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;
@Component
@ConfigurationProperties("limits-service")
public class Configuration {
	private int maximum;
	private int minimum;
	public void setMaximum(int maximum) {
		this.maximum = maximum;		}
	public void setMinimum(int minimum) {
		this.minimum = minimum;		}
	public int getMaximum() {
		return maximum;		}
	public int getMinimum() {
		return minimum;		}
}




LimitsConfigurationController:

package com.example.demo.controller;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import com.example.demo.bean.LimitConfiguration;
import com.example.demo.*;
@RestController
public class LimitsConfigurationController {
	@Autowired
	private Configuration configuration;
	@GetMapping("/limits")
	public LimitConfiguration retriveLimitsFromConfigurations() {
//getting values from the properties file  
		return new LimitConfiguration(configuration.getMaximum(), configuration.getMinimum());
	}
}



application.properties:

spring.application.name=limits-service
spring.cloud.config.enabled=false

limits-service.minimum=99  
limits-service.maximum=9999 






Example:
Project: Eureka Server

Create a spring starter project: eureka-server
Package: com.eureka_server

Add Eureka server as dependency

Edit application.properties
Main class: EurekaServerApplication






package com.eureka_server;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {

	public static void main(String[] args) {
		SpringApplication.run(EurekaServerApplication.class, args);
	}

}





spring.application.name=eureka-server
server.port=8761
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
eureka.instance.hostname=localhost





Project : Client 1:

Project: microservice-one
Package: com.microservice_one
Dependencies: 
Eureka Discovery Client, 
Spring Web 
OpenFeign

Edit Main App: MicroserviceOneApplication
In client package: Add Interface : MicroserviceTwoClient
In controller package: Add Class: HelloController 
Edit : application.properties






package com.microservice_one;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients
public class MicroserviceOneApplication {
    public static void main(String[] args) {
        SpringApplication.run(MicroserviceOneApplication.class, args);
    }
}





package com.microservice_one.client;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;

@FeignClient(name = "microservice-two")
public interface MicroserviceTwoClient {
	@GetMapping("/hello")
	String getHello();
}






package com.microservice_one.controller;

import com.microservice_one.client.MicroserviceTwoClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {

    @Autowired
    private MicroserviceTwoClient microserviceTwoClient;

    @GetMapping("/hello")
    public String hello() {
        return "Hello from Microservice One";
    }

    @GetMapping("/call-microservice-two")
    public String callMicroserviceTwo() {
        return microserviceTwoClient.getHello();
    }
}






spring.application.name=microservice-one
server.port=8081
eureka.client.service-url.defaultZone=http://localhost:8761/eureka





Client 2:

Project: microservice-two
Package: com.microservice_two
Dependencies: 
Eureka Discovery Client, 
Spring Web 

Edit Main App: MicroserviceTwoApplication
In controller package: Add Class: HelloController 
Edit : application.properties




package com.microservice_two;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient
public class MicroserviceTwoApplication {
    public static void main(String[] args) {
        SpringApplication.run(MicroserviceTwoApplication.class, args);
    }
}





package com.microservice_two.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {

    @GetMapping("/hello")
    public String hello() {
        return "Hello from Microservice Two";
    }

}






spring.application.name=microservice-two
server.port=8082
eureka.client.service-url.defaultZone=http://localhost:8761/eureka



This new microservice : microservice-three and will manage a simple entity, Employee. 
We'll follow these steps:
Create microservice-three project.
Add necessary dependencies.
Create the Employee entity and repository.
Create a service and controller.
Configure the H2 database.
Connect microservice-three with Eureka Server.
Step 1: Create microservice-three project
Create a new Spring Boot project for the third microservice:
Project name: microservice-three
Dependencies: Eureka Discovery, Web, JPA, H2
Step 2: Add necessary dependencies
Configure pom.xml:
<dependencies>
    <!-- Spring Boot Starter Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!-- Spring Boot Starter Data JPA -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <!-- H2 Database -->
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <scope>runtime</scope>
    </dependency>
    <!-- Eureka Client -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>
</dependencies>
 
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>2022.0.3</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
Step 3: Create the Employee entity and repository
Create the Employee entity class:
 
package com.example.microservicethree.model;
 
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
 
@Entity
public class Employee {
 
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String position;
 
    // Getters and setters
    public Long getId() {
        return id;
    }
 
    public void setId(Long id) {
        this.id = id;
    }
 
    public String getName() {
        return name;
    }
 
    public void setName(String name) {
        this.name = name;
    }
 
    public String getPosition() {
        return position;
    }
 
    public void setPosition(String position) {
        this.position = position;
    }
}
Create the EmployeeRepository interface:
package com.example.microservicethree.repository;
 
import com.example.microservicethree.model.Employee;
import org.springframework.data.jpa.repository.JpaRepository;
 
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
}
Step 4: Create a service and controller
Create the EmployeeService class:
package com.example.microservicethree.service;
 
import com.example.microservicethree.model.Employee;
import com.example.microservicethree.repository.EmployeeRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
 
import java.util.List;
 
@Service
public class EmployeeService {
 
    @Autowired
    private EmployeeRepository employeeRepository;
 
    public List<Employee> getAllEmployees() {
        return employeeRepository.findAll();
    }
 
    public Employee getEmployeeById(Long id) {
        return employeeRepository.findById(id).orElse(null);
    }
 
    public Employee saveEmployee(Employee employee) {
        return employeeRepository.save(employee);
    }
 
    public void deleteEmployee(Long id) {
        employeeRepository.deleteById(id);
    }
}
Create the EmployeeController class:
package com.example.microservicethree.controller;
 
import com.example.microservicethree.model.Employee;
import com.example.microservicethree.service.EmployeeService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
 
import java.util.List;
 
@RestController
@RequestMapping("/employees")
public class EmployeeController {
 
    @Autowired
    private EmployeeService employeeService;
 
    @GetMapping
    public List<Employee> getAllEmployees() {
        return employeeService.getAllEmployees();
    }
 
    @GetMapping("/{id}")
    public Employee getEmployeeById(@PathVariable Long id) {
        return employeeService.getEmployeeById(id);
    }
 
    @PostMapping
    public Employee createEmployee(@RequestBody Employee employee) {
        return employeeService.saveEmployee(employee);
    }
 
    @PutMapping("/{id}")
    public Employee updateEmployee(@PathVariable Long id, @RequestBody Employee employeeDetails) {
        Employee employee = employeeService.getEmployeeById(id);
        if (employee != null) {
            employee.setName(employeeDetails.getName());
            employee.setPosition(employeeDetails.getPosition());
            return employeeService.saveEmployee(employee);
        }
        return null;
    }
 
    @DeleteMapping("/{id}")
    public void deleteEmployee(@PathVariable Long id) {
        employeeService.deleteEmployee(id);
    }
}
Step 5: Configure the H2 database
Configure application.properties for microservice-three:
spring.application.name=microservice-three
server.port=8083
eureka.client.service-url.defaultZone=http://localhost:8761/eureka
 
spring.h2.console.enabled=true
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=password
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
 
Step 6: Connect microservice-three with Eureka Server
Enable Eureka Client in microservice-three main application class:
package com.example.microservicethree;
 
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
 
@SpringBootApplication
@EnableEurekaClient
public class MicroserviceThreeApplication {
    public static void main(String[] args) {
        SpringApplication.run(MicroserviceThreeApplication.class, args);
    }
}
Step 7: Run and Test
Run Eureka Server:
Right-click the eureka-server project and select Run As > Spring Boot App.
Run Microservice One:
Right-click the microservice-one project and select Run As > Spring Boot App.
Run Microservice Two:
Right-click the microservice-two project and select Run As > Spring Boot App.
Run Microservice Three:
Right-click the microservice-three project and select Run As > Spring Boot App.
Test the H2 database and CRUD operations:
Access http://localhost:8083/h2-console to view the H2 database console.
Test the CRUD operations on http://localhost:8083/employees using a tool like Postman or a web browser.
By following these steps, you will have an additional microservice (microservice-three) that uses an H2 database and performs CRUD operations, and is registered with the Eureka Server.
 




