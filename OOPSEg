package Day1;

public class Emp { //encapsulated: Capsulating/blueprint of the Emp Object 
	protected int empId;  // encapsulated : Data hiding via protected 
	protected int sal;
	protected String name;
	public void input(int id, int s, String n) { //Abstraction via public keyword
		empId=id;
		sal=s;
		name=n;
	}
	public void print() {
		System.out.println("The Emp object : ID : " + empId + " with Name : " + name + " earning Rs." + sal);
	}
}



package Day1;

public class Developers extends Emp {   //Inheritance
	private int projectId; // encapsulated : Data hiding via protected 
	public void input(int id, int s, String n, int pid) {  //overloading with Inheritance
		projectId=pid;
		input(id,  s, n);
	}
	public void print() { //Overriding
		System.out.println("The Emp object : ID : " + 
			empId + " with Name : " + name + " earning Rs." + 
				sal + " Handling the Project : " + projectId);
	}
	

}




package Day1;

public class Main {  //Polymorphism : Overloading
	public void print() { //Case 1
		System.out.println("Print()");
	}
	public void print(int i) { //case 2: Overloading 1, as no of parameters are diff
		System.out.println("Print(int i)");
	}
	public void print(int i, String s) { //case 3: Overloading 1,2 as no of parameters are diff
		System.out.println("Print(int i, String s)");
	}
	public void print(String s, int i) { 
		//case 4: Overloading 1,2 as no of parameters are diff
		//: Overloading 3, as series of parameter are diff
		System.out.println("Print(String s, int i)");
	}
	public void print(String s) { 
		//case 5: Overloading 1,3,4 as no of parameters are diff
		//: Overloading 2, as data type of parameter are diff
		System.out.println("Print(String s)");
	}
	
	public static void main(String[] args) {
		Main m=new Main();
		m.print();
		m.print("Hello");
		m.print(10,"H");
		m.print("H",10);
		m.print(10);
		

	}

}




package Day1;

public class EmpMain {

	public static void main(String[] args) {
		Emp e1 = new Emp();
		e1.input(101, 10, "John Doe");
		Developers e2 =new Developers();
		e2.input(101, 10, "John Doe",103);
		e1.print();
		e2.print();
		

	}

}








package Day1.pkg1;

public class Ambani {
	public void Reliance() {
		System.out.print(" Reliance ; ");
	}
	private void CC() {
		System.out.print(" CC  ; ");
	}
	protected void NetBank() {
		System.out.print("  Net Banking Account ; ");
	}
	void Gold() {
		System.out.print(" Almirah full of gold ; ");
	}
	public void print() {
		System.out.println("\nThis is Ambani in pkg1: I can access : ");
		Reliance();
		NetBank();
		Gold();
		CC();			
	}

}



package Day1.pkg1;

public class Akash extends Ambani{
	
	public void print() {
		System.out.println("\nThis is AKash : Ambani in same pkg1: I can access : ");
		Reliance();
		NetBank();
		Gold();
		//CC();			
	}
}




package Day1.pkg2;

import Day1.pkg1.Ambani;

public class Anant extends Ambani{
	
	public void print() {
		System.out.println("\nThis is Anant : Ambani in pkg2: I can access : ");
		Reliance();
		NetBank();
		//Gold();
		//CC();			
	}
}




package Day1.pkg1;

public class Kaka {
	public void print() {
		System.out.println("\nThis is Kaka in pkg1: I can access : ");
		Ambani a =new Ambani();
		a.Reliance();
		a.NetBank();
		a.Gold();
		//a.CC();			
	}

}




package Day1.pkg2;

import Day1.pkg1.Ambani;

public class Radhe {
	public void print() {
		System.out.println("\nThis is Radhe in pkg2:  I can access : ");
		Ambani a =new Ambani();
		a.Reliance();
		//a.NetBank();
		//a.Gold();
		//a.CC();			
	}
}




package Day1;
import Day1.pkg1.*;
import Day1.pkg2.*;

public class MainPkgClass {

	public static void main(String[] args) {
		new Ambani().print();
		new Akash().print();
		new Anant().print();
		new Kaka().print();
		new Radhe().print();

	}

}




package Day1;

import java.util.Objects;

public class Employee {
	public int id;
	public String name;

	public Employee() { // default constructor
		System.out.println(id + " : " + name);
	}

	public Employee(int id, String name) {
		this.id = id;
		this.name = name;
		System.out.println(id + " : " + name);
	}

	@Override
	public String toString() {
		return "Employee [id=" + id + ", name=" + name + "]";
	}

	@Override
	public int hashCode() {
		return id;
	}

	@Override
	public boolean equals(Object obj) {
		Employee other = (Employee) obj;
		return id == other.id;
	}

	@Override
	protected void finalize() throws Throwable {
		// TODO Auto-generated method stub
		System.out.println("This will clean up the Object");
	}

	public static void main(String[] args) {
		{
			Employee e1 = new Employee();
			System.out.println(e1);
			Employee e2 = new Employee();
			System.out.println(e2);
			if (e1.equals(e2))
				System.out.println("e1==e2");
			else
				System.out.println("e1!=e2");
		}
		
		System.gc();
		
		System.out.println("e1, e2 Out of Range ");
	}

}






package Day1;

public class POJO {
	private int field1;
	public int getField1() {
		return field1;
	}
	public void setField1(int field1) {
		this.field1 = field1;
	}	
	public POJO(int field1) {
		super();
		this.field1 = field1;
	}	
	public POJO() {}		
	@Override
	public String toString() {
		return "POJO [field1=" + field1 + "]";
	}	
	//override hashCode and equals methods together
	//main() not allowed
}



Class of Java applying to compliances is a Java Bean:
1. If any Constructor is planned, have a default constructor also
2. Every attribute should have properties , if they are private
3. Every behaviour should be public 
4. The class should override toString()
5. If Serializable, the Object should have a strong uuid.
6. All classes should be public 
7. If equals operator is overridden, hashCode should also be overridden
8. If Scoped objects are not created, destroy the objects by forcefully calling System.gc() and finalizing the object










