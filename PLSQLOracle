set serveroutput on; 

DECLARE
    v_event VARCHAR2(15);
BEGIN
   v_event  := q'!Father's day!';
  DBMS_OUTPUT.PUT_LINE('3rd Sunday in June is :   '|| v_event );
   v_event  := q'[Mother's day]';
  DBMS_OUTPUT.PUT_LINE('2nd Sunday in May is :   '|| v_event );
END;
/










DECLARE 
 var_salary number(6);
 var_emp_id number(6) := 100;
 BEGIN 
SELECT salary  INTO var_salary  FROM employees  
WHERE employee_id = var_emp_id; 

dbms_output.put_line(var_salary);  
dbms_output.put_line('The employee ' || var_emp_id || ' has salary ' || var_salary); 
END;
 /




DECLARE
 var_num1 number;
 var_num2 number;
BEGIN
 var_num1 := 100;
 var_num2 := 200;
 DECLARE
  var_mult number;
  BEGIN
   var_mult := var_num1 * var_num2;
   dbms_output.put_line(var_mult);
  END;
   -- dbms_output.put_line(var_mult);
END;
/





DECLARE
  n_emp_id EMPLOYEES.EMPLOYEE_ID%TYPE := &emp_id1;
BEGIN
  DECLARE
    n_emp_id employees.employee_id%TYPE := &emp_id2;
    v_name employees.first_name%TYPE;
    BEGIN
     SELECT first_name INTO v_name 
        FROM employees WHERE employee_id = n_emp_id;
     DBMS_OUTPUT.PUT_LINE('First name of employee ' || n_emp_id || ' is ' || v_name);
    END;
END;
/





BEGIN <<outer>>
DECLARE
 v_father_name VARCHAR2(20):='James';
 v_date_of_birth DATE:='20-oct-2014';
BEGIN
  DECLARE
   v_child_name VARCHAR2(20):='Devins';
   v_date_of_birth DATE:='12-jun-2004';
  BEGIN
   DBMS_OUTPUT.PUT_LINE('Father''s Name: '||v_father_name);
   DBMS_OUTPUT.PUT_LINE('Date of Birth: '
                        ||outer.v_date_of_birth);
   DBMS_OUTPUT.PUT_LINE('Child''s Name: '||v_child_name);
   DBMS_OUTPUT.PUT_LINE('Date of Birth: '||v_date_of_birth);
  END;
END;  
END outer;
/





DECLARE
 a number(2) := &ano;
 BEGIN 
    IF( a < 20 )  THEN 
        dbms_output.put_line('a is less than 20 ' ); 
    END IF;
    dbms_output.put_line('value of a is : ' || a); 
END; 
/



DECLARE
 a number(2) := 10;
 BEGIN 
    a:= 10;  
    IF( a < 20 )  THEN 
        dbms_output.put_line('a is less than 20 ' ); 
    ELSE 
        dbms_output.put_line('a is not less than 20 ' ); 
    END IF;
    dbms_output.put_line('value of a is : ' || a); 
END; 
/





DECLARE 
	a number(3) := 100; 
BEGIN 
	IF ( a = 10 ) THEN 
        dbms_output.put_line('Value of a is 10' ); 
    ELSIF ( a = 20 ) THEN 
        dbms_output.put_line('Value of a is 20' ); 
    ELSIF ( a = 30 ) THEN 
        dbms_output.put_line('Value of a is 30' ); 
    ELSE 
        dbms_output.put_line('None of the values is matching'); 
    END IF;
    dbms_output.put_line('Exact value of a is: '|| a ); 
END;    
/





DECLARE 
	a number(3) := 100; 
	b number(3) := 200;
 BEGIN 
	-- check the boolean condition 
IF( a = 100 ) THEN 
	-- if condition is true then check the following 
  IF( b = 200 ) THEN 
	-- if condition is true then print the following 
	dbms_output.put_line('Value of a is 100 and b is 200' );
   END IF;
 END IF; 
dbms_output.put_line('Exact value of a is : ' || a ); dbms_output.put_line('Exact value of b is : ' || b ); 
END; /





DECLARE 
	grade char(1) := 'A'; 
BEGIN 
	CASE grade 
        when 'A' then dbms_output.put_line('Excellent'); 
        when 'B' then dbms_output.put_line('Very good'); 
        when 'C' then dbms_output.put_line('Well done'); 
        when 'D' then dbms_output.put_line('You passed'); 
        when 'F' then dbms_output.put_line('Better try again');
 	else 
        dbms_output.put_line('No such grade'); 
	END CASE; 
END; 
/



DECLARE 
	grade char(1) := '&grade'; 
BEGIN 
    select upper(grade) into grade from dual;
	CASE grade 
        when 'A' then dbms_output.put_line('Excellent'); 
        when 'B' then dbms_output.put_line('Very good'); 
        when 'C' then dbms_output.put_line('Well done'); 
        when 'D' then dbms_output.put_line('You passed'); 
        when 'F' then dbms_output.put_line('Better try again');
 	else 
        dbms_output.put_line('No such grade'); 
	END CASE; 
END; 
/





DECLARE 
	grade char(1) := 'B'; 
BEGIN 
	case 
        when grade = 'A' then 
            dbms_output.put_line('Excellent'); 
        when grade = 'B' then 
            dbms_output.put_line('Very good'); 
        when grade = 'C' then 
            dbms_output.put_line('Well done'); 
        when grade = 'D' then 
            dbms_output.put_line('You passed'); 
        when grade = 'F' then 
            dbms_output.put_line('Better try again'); 
        else 
            dbms_output.put_line('No such grade'); 
    end case;  
END;   
/



DECLARE 
	grade char(1) := '&grade'; 
BEGIN 
    select upper(grade) into grade from dual;
	case 
        when grade = 'A' then 
            dbms_output.put_line('Excellent'); 
        when grade = 'B' then 
            dbms_output.put_line('Very good'); 
        when grade = 'C' then 
            dbms_output.put_line('Well done'); 
        when grade = 'D' then 
            dbms_output.put_line('You passed'); 
        when grade = 'F' then 
            dbms_output.put_line('Better try again'); 
        else 
            dbms_output.put_line('No such grade'); 
    end case;  
END; 
/



DECLARE 
    TYPE emp_rec_type IS RECORD
        (employee_id  NUMBER(6) NOT NULL := 101,
        last_name  emp3.last_name%TYPE);

	emp_record   emp_rec_type; --empId and lastname
	emp_rec emp3%ROWTYPE; --all columns of emp3
BEGIN
	--SELECT * INTO emp_rec from emp3 WHERE employee_id=&a;
    SELECT employee_id, last_name INTO emp_record from emp3 WHERE employee_id=&a;
	DBMS_OUTPUT.PUT_LINE( emp_record.last_name||' ' || emp_record.employee_id);
END;
/





drop table customers;

create table customers as 
	select Employee_id as id, first_name||' '||last_name as name, 
	email as address, salary from employees;

select * from customers;



DECLARE
	 total_rows number(8);
 BEGIN 
UPDATE customers SET salary = salary + 500; 
IF sql%notfound THEN 
dbms_output.put_line('no customers selected'); 
ELSIF sql%found THEN 
total_rows := sql%rowcount; 
dbms_output.put_line( total_rows || ' customers selected '); 
END IF; 
END;  
/


Cursor Attributes
%FOUND
Returns TRUE if an INSERT, UPDATE, or DELETE statement affected one or more rows or a SELECT INTO statement returned one or more rows. Otherwise, it returns FALSE.
%NOTFOUND
The logical opposite of %FOUND. It returns TRUE if an INSERT, UPDATE, or DELETE statement affected no rows, or a SELECT INTO statement returned no rows. Otherwise, it returns FALSE.
%ISOPEN
Always returns FALSE for implicit cursors, because Oracle closes the SQL cursor automatically after executing its associated SQL statement.
%ROWCOUNT
Returns the number of rows affected by an INSERT, UPDATE, or DELETE statement, or returned by a SELECT INTO statement.





DECLARE 
   x number := 10; 
BEGIN 
   LOOP 
      dbms_output.put_line(x); 
      x := x + 10; 
      IF x > 50 THEN 
         exit; 
      END IF; 
   END LOOP; 
   -- after exit, control resumes here  
   dbms_output.put_line('After Exit x is: ' || x); 
END; 
/





DECLARE 
   x number := 10; 
BEGIN 
   LOOP 
      dbms_output.put_line(x); 
      x := x + 10; 
      exit WHEN x > 50; 
   END LOOP; 
   -- after exit, control resumes here 
   dbms_output.put_line('After Exit x is: ' || x); 
END; 
/


DECLARE 
   a number(2) := 10; 
BEGIN 
   WHILE a < 20 LOOP 
      dbms_output.put_line('value of a: ' || a); 
      a := a + 1; 
   END LOOP; 
END; 
/ 



DECLARE 
   a number(2); 
BEGIN 
   FOR a in 10 .. 20 LOOP 
      dbms_output.put_line('value of a: ' || a); 
  END LOOP; 
END; 
/





DECLARE 
   a number(2) ; 
BEGIN 
   FOR a IN REVERSE 10 .. 20 LOOP 
      dbms_output.put_line('value of a: ' || a); 
   END LOOP; 
END; 
/





PL/SQL allows using one loop inside another loop.
The syntax for a nested basic LOOP statement in PL/SQL is as follows −
LOOP 
   Sequence of statements1 
   LOOP 
      Sequence of statements2 
   END LOOP; 
END LOOP;

The syntax for a nested FOR LOOP statement in PL/SQL is as follows −
FOR counter1 IN initial_value1 .. final_value1 LOOP 
   sequence_of_statements1 
   FOR counter2 IN initial_value2 .. final_value2 LOOP 
      sequence_of_statements2 
   END LOOP; 
END LOOP;

The syntax for a nested WHILE LOOP statement in Pascal is as follows −
WHILE condition1 LOOP 
   sequence_of_statements1 
   WHILE condition2 LOOP 
      sequence_of_statements2 
   END LOOP; 
END LOOP; 





DECLARE 
   i number(3); 
   j number(3); 
BEGIN 
   i := 2; 
   LOOP 
      j:= 2; 
      LOOP 
         exit WHEN ((mod(i, j) = 0) or (j = i)); 
         j := j +1; 
      END LOOP; 
   IF (j = i ) THEN 
      dbms_output.put_line(i || ' is prime'); 
   END IF; 
   i := i + 1; 
   exit WHEN i = 50; 
   END LOOP; 
END; 
/



DECLARE 
   i number(1); 
   j number(1); 
BEGIN 
   << outer_loop >> 
   FOR i IN 1..3 LOOP 
      << inner_loop >> 
      FOR j IN 1..3 LOOP 
         dbms_output.put_line('i is: '|| i || ' and j is: ' || j); 
      END loop inner_loop; 
   END loop outer_loop; 
END; 
/



DECLARE 
   a number(2) := 10; 
BEGIN 
   -- while loop execution  
   WHILE a < 20 LOOP 
      dbms_output.put_line ('value of a: ' || a); 
      a := a + 1; 
      IF a > 15 THEN 
         -- terminate the loop using the exit statement 
         EXIT; 
      END IF; 
   END LOOP; 
END; 
/




DECLARE 
   a number(2) := 10; 
BEGIN 
   -- while loop execution  
   WHILE a < 20 LOOP 
      dbms_output.put_line ('value of a: ' || a); 
      a := a + 1; 
      IF a = 15 THEN 
         -- skip the loop using the CONTINUE statement 
         a := a + 1; 
         CONTINUE; 
      END IF; 
   END LOOP; 
END; 
/ 





DECLARE 
   a number(2) := 10; 
BEGIN 
   <<loopstart>> 
   -- while loop execution  
   WHILE a < 20 LOOP
   dbms_output.put_line ('value of a: ' || a); 
      a := a + 1; 
      IF a = 15 THEN 
         a := a + 1; 
         GOTO loopstart; 
      END IF; 
   END LOOP; 
END; 
/








