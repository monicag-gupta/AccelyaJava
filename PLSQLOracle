set serveroutput on; 

DECLARE
    v_event VARCHAR2(15);
BEGIN
   v_event  := q'!Father's day!';
  DBMS_OUTPUT.PUT_LINE('3rd Sunday in June is :   '|| v_event );
   v_event  := q'[Mother's day]';
  DBMS_OUTPUT.PUT_LINE('2nd Sunday in May is :   '|| v_event );
END;
/










DECLARE 
 var_salary number(6);
 var_emp_id number(6) := 100;
 BEGIN 
SELECT salary  INTO var_salary  FROM employees  
WHERE employee_id = var_emp_id; 

dbms_output.put_line(var_salary);  
dbms_output.put_line('The employee ' || var_emp_id || ' has salary ' || var_salary); 
END;
 /




DECLARE
 var_num1 number;
 var_num2 number;
BEGIN
 var_num1 := 100;
 var_num2 := 200;
 DECLARE
  var_mult number;
  BEGIN
   var_mult := var_num1 * var_num2;
   dbms_output.put_line(var_mult);
  END;
   -- dbms_output.put_line(var_mult);
END;
/





DECLARE
  n_emp_id EMPLOYEES.EMPLOYEE_ID%TYPE := &emp_id1;
BEGIN
  DECLARE
    n_emp_id employees.employee_id%TYPE := &emp_id2;
    v_name employees.first_name%TYPE;
    BEGIN
     SELECT first_name INTO v_name 
        FROM employees WHERE employee_id = n_emp_id;
     DBMS_OUTPUT.PUT_LINE('First name of employee ' || n_emp_id || ' is ' || v_name);
    END;
END;
/





BEGIN <<outer>>
DECLARE
 v_father_name VARCHAR2(20):='James';
 v_date_of_birth DATE:='20-oct-2014';
BEGIN
  DECLARE
   v_child_name VARCHAR2(20):='Devins';
   v_date_of_birth DATE:='12-jun-2004';
  BEGIN
   DBMS_OUTPUT.PUT_LINE('Father''s Name: '||v_father_name);
   DBMS_OUTPUT.PUT_LINE('Date of Birth: '
                        ||outer.v_date_of_birth);
   DBMS_OUTPUT.PUT_LINE('Child''s Name: '||v_child_name);
   DBMS_OUTPUT.PUT_LINE('Date of Birth: '||v_date_of_birth);
  END;
END;  
END outer;
/





DECLARE
 a number(2) := &ano;
 BEGIN 
    IF( a < 20 )  THEN 
        dbms_output.put_line('a is less than 20 ' ); 
    END IF;
    dbms_output.put_line('value of a is : ' || a); 
END; 
/



DECLARE
 a number(2) := 10;
 BEGIN 
    a:= 10;  
    IF( a < 20 )  THEN 
        dbms_output.put_line('a is less than 20 ' ); 
    ELSE 
        dbms_output.put_line('a is not less than 20 ' ); 
    END IF;
    dbms_output.put_line('value of a is : ' || a); 
END; 
/





DECLARE 
	a number(3) := 100; 
BEGIN 
	IF ( a = 10 ) THEN 
        dbms_output.put_line('Value of a is 10' ); 
    ELSIF ( a = 20 ) THEN 
        dbms_output.put_line('Value of a is 20' ); 
    ELSIF ( a = 30 ) THEN 
        dbms_output.put_line('Value of a is 30' ); 
    ELSE 
        dbms_output.put_line('None of the values is matching'); 
    END IF;
    dbms_output.put_line('Exact value of a is: '|| a ); 
END;    
/





DECLARE 
	a number(3) := 100; 
	b number(3) := 200;
 BEGIN 
	-- check the boolean condition 
IF( a = 100 ) THEN 
	-- if condition is true then check the following 
  IF( b = 200 ) THEN 
	-- if condition is true then print the following 
	dbms_output.put_line('Value of a is 100 and b is 200' );
   END IF;
 END IF; 
dbms_output.put_line('Exact value of a is : ' || a ); dbms_output.put_line('Exact value of b is : ' || b ); 
END; /





DECLARE 
	grade char(1) := 'A'; 
BEGIN 
	CASE grade 
        when 'A' then dbms_output.put_line('Excellent'); 
        when 'B' then dbms_output.put_line('Very good'); 
        when 'C' then dbms_output.put_line('Well done'); 
        when 'D' then dbms_output.put_line('You passed'); 
        when 'F' then dbms_output.put_line('Better try again');
 	else 
        dbms_output.put_line('No such grade'); 
	END CASE; 
END; 
/



DECLARE 
	grade char(1) := '&grade'; 
BEGIN 
    select upper(grade) into grade from dual;
	CASE grade 
        when 'A' then dbms_output.put_line('Excellent'); 
        when 'B' then dbms_output.put_line('Very good'); 
        when 'C' then dbms_output.put_line('Well done'); 
        when 'D' then dbms_output.put_line('You passed'); 
        when 'F' then dbms_output.put_line('Better try again');
 	else 
        dbms_output.put_line('No such grade'); 
	END CASE; 
END; 
/





DECLARE 
	grade char(1) := 'B'; 
BEGIN 
	case 
        when grade = 'A' then 
            dbms_output.put_line('Excellent'); 
        when grade = 'B' then 
            dbms_output.put_line('Very good'); 
        when grade = 'C' then 
            dbms_output.put_line('Well done'); 
        when grade = 'D' then 
            dbms_output.put_line('You passed'); 
        when grade = 'F' then 
            dbms_output.put_line('Better try again'); 
        else 
            dbms_output.put_line('No such grade'); 
    end case;  
END;   
/



DECLARE 
	grade char(1) := '&grade'; 
BEGIN 
    select upper(grade) into grade from dual;
	case 
        when grade = 'A' then 
            dbms_output.put_line('Excellent'); 
        when grade = 'B' then 
            dbms_output.put_line('Very good'); 
        when grade = 'C' then 
            dbms_output.put_line('Well done'); 
        when grade = 'D' then 
            dbms_output.put_line('You passed'); 
        when grade = 'F' then 
            dbms_output.put_line('Better try again'); 
        else 
            dbms_output.put_line('No such grade'); 
    end case;  
END; 
/



DECLARE 
    TYPE emp_rec_type IS RECORD
        (employee_id  NUMBER(6) NOT NULL := 101,
        last_name  emp3.last_name%TYPE);

	emp_record   emp_rec_type; --empId and lastname
	emp_rec emp3%ROWTYPE; --all columns of emp3
BEGIN
	--SELECT * INTO emp_rec from emp3 WHERE employee_id=&a;
    SELECT employee_id, last_name INTO emp_record from emp3 WHERE employee_id=&a;
	DBMS_OUTPUT.PUT_LINE( emp_record.last_name||' ' || emp_record.employee_id);
END;
/





drop table customers;

create table customers as 
	select Employee_id as id, first_name||' '||last_name as name, 
	email as address, salary from employees;

select * from customers;



DECLARE
	 total_rows number(8);
 BEGIN 
UPDATE customers SET salary = salary + 500; 
IF sql%notfound THEN 
dbms_output.put_line('no customers selected'); 
ELSIF sql%found THEN 
total_rows := sql%rowcount; 
dbms_output.put_line( total_rows || ' customers selected '); 
END IF; 
END;  
/


Cursor Attributes
%FOUND
Returns TRUE if an INSERT, UPDATE, or DELETE statement affected one or more rows or a SELECT INTO statement returned one or more rows. Otherwise, it returns FALSE.
%NOTFOUND
The logical opposite of %FOUND. It returns TRUE if an INSERT, UPDATE, or DELETE statement affected no rows, or a SELECT INTO statement returned no rows. Otherwise, it returns FALSE.
%ISOPEN
Always returns FALSE for implicit cursors, because Oracle closes the SQL cursor automatically after executing its associated SQL statement.
%ROWCOUNT
Returns the number of rows affected by an INSERT, UPDATE, or DELETE statement, or returned by a SELECT INTO statement.





DECLARE 
   x number := 10; 
BEGIN 
   LOOP 
      dbms_output.put_line(x); 
      x := x + 10; 
      IF x > 50 THEN 
         exit; 
      END IF; 
   END LOOP; 
   -- after exit, control resumes here  
   dbms_output.put_line('After Exit x is: ' || x); 
END; 
/





DECLARE 
   x number := 10; 
BEGIN 
   LOOP 
      dbms_output.put_line(x); 
      x := x + 10; 
      exit WHEN x > 50; 
   END LOOP; 
   -- after exit, control resumes here 
   dbms_output.put_line('After Exit x is: ' || x); 
END; 
/


DECLARE 
   a number(2) := 10; 
BEGIN 
   WHILE a < 20 LOOP 
      dbms_output.put_line('value of a: ' || a); 
      a := a + 1; 
   END LOOP; 
END; 
/ 



DECLARE 
   a number(2); 
BEGIN 
   FOR a in 10 .. 20 LOOP 
      dbms_output.put_line('value of a: ' || a); 
  END LOOP; 
END; 
/





DECLARE 
   a number(2) ; 
BEGIN 
   FOR a IN REVERSE 10 .. 20 LOOP 
      dbms_output.put_line('value of a: ' || a); 
   END LOOP; 
END; 
/





PL/SQL allows using one loop inside another loop.
The syntax for a nested basic LOOP statement in PL/SQL is as follows −
LOOP 
   Sequence of statements1 
   LOOP 
      Sequence of statements2 
   END LOOP; 
END LOOP;

The syntax for a nested FOR LOOP statement in PL/SQL is as follows −
FOR counter1 IN initial_value1 .. final_value1 LOOP 
   sequence_of_statements1 
   FOR counter2 IN initial_value2 .. final_value2 LOOP 
      sequence_of_statements2 
   END LOOP; 
END LOOP;

The syntax for a nested WHILE LOOP statement in Pascal is as follows −
WHILE condition1 LOOP 
   sequence_of_statements1 
   WHILE condition2 LOOP 
      sequence_of_statements2 
   END LOOP; 
END LOOP; 





DECLARE 
   i number(3); 
   j number(3); 
BEGIN 
   i := 2; 
   LOOP 
      j:= 2; 
      LOOP 
         exit WHEN ((mod(i, j) = 0) or (j = i)); 
         j := j +1; 
      END LOOP; 
   IF (j = i ) THEN 
      dbms_output.put_line(i || ' is prime'); 
   END IF; 
   i := i + 1; 
   exit WHEN i = 50; 
   END LOOP; 
END; 
/



DECLARE 
   i number(1); 
   j number(1); 
BEGIN 
   << outer_loop >> 
   FOR i IN 1..3 LOOP 
      << inner_loop >> 
      FOR j IN 1..3 LOOP 
         dbms_output.put_line('i is: '|| i || ' and j is: ' || j); 
      END loop inner_loop; 
   END loop outer_loop; 
END; 
/



DECLARE 
   a number(2) := 10; 
BEGIN 
   -- while loop execution  
   WHILE a < 20 LOOP 
      dbms_output.put_line ('value of a: ' || a); 
      a := a + 1; 
      IF a > 15 THEN 
         -- terminate the loop using the exit statement 
         EXIT; 
      END IF; 
   END LOOP; 
END; 
/




DECLARE 
   a number(2) := 10; 
BEGIN 
   -- while loop execution  
   WHILE a < 20 LOOP 
      dbms_output.put_line ('value of a: ' || a); 
      a := a + 1; 
      IF a = 15 THEN 
         -- skip the loop using the CONTINUE statement 
         a := a + 1; 
         CONTINUE; 
      END IF; 
   END LOOP; 
END; 
/ 





DECLARE 
   a number(2) := 10; 
BEGIN 
   <<loopstart>> 
   -- while loop execution  
   WHILE a < 20 LOOP
   dbms_output.put_line ('value of a: ' || a); 
      a := a + 1; 
      IF a = 15 THEN 
         a := a + 1; 
         GOTO loopstart; 
      END IF; 
   END LOOP; 
END; 
/



GOTO Statement in PL/SQL imposes the following restrictions −
A GOTO statement cannot branch into an IF statement, CASE statement, LOOP statement or sub-block.
A GOTO statement cannot branch from one IF statement clause to another or from one CASE statement WHEN clause to another.
A GOTO statement cannot branch from an outer block into a sub-block (i.e., an inner BEGIN-END block).
A GOTO statement cannot branch out of a subprogram. To end a subprogram early, either use the RETURN statement or have GOTO branch to a place right before the end of the subprogram.
A GOTO statement cannot branch from an exception handler back into the current BEGIN-END block. However, a GOTO statement can branch from an exception handler into an enclosing block.


Working with an explicit cursor involves four steps:
	Declaring the cursor for initializing in the memory
	Opening the cursor for allocating memory
	Fetching the cursor for retrieving data
	Closing the cursor to release allocated memory



Declaring the Cursor
	CURSOR c_customers IS SELECT id, name, address FROM customers;

Opening the Cursor
	OPEN c_customers;
Fetching the Cursor
	FETCH c_customers INTO c_id, c_name, c_addr;

Closing the Cursor
	CLOSE c_customers;


DECLARE
 	c_id customers.id%type; 
	c_name customers.name%type; 
	c_addr customers.address%type; 
	CURSOR c_customers is SELECT id, name, address FROM customers;
BEGIN 
	OPEN c_customers; 
	LOOP 
        FETCH c_customers into c_id, c_name, c_addr; 
        EXIT WHEN c_customers%notfound; 
        dbms_output.put_line(c_id || ' ' || c_name || ' ' || c_addr); 
	END LOOP; 
	CLOSE c_customers; 
END; 
/




Useful VARRAY Methods
	COUNT → number of elements currently in array
	EXTEND → add one (or n) elements at the end
	TRIM → remove last element
	DELETE → not allowed in VARRAYs (only in nested tables)
	LIMIT → max size
	VARRAY (Variable-size Array) is a collection type in Oracle PL/SQL.
Stores a fixed maximum number of elements (defined at declaration).
Unlike nested tables, VARRAYs preserve order and are always dense (no gaps between elements).
Elements can be accessed by index (1-based).



DECLARE 
   type namesarray IS VARRAY(5) OF VARCHAR2(10); 
   type grades IS VARRAY(5) OF INTEGER; 
   names namesarray; 
   marks grades; 
   total integer; 
BEGIN 
   names := namesarray('a1', 'b12', 'c123', 'd1234', 'e125'); 
   marks:= grades(98, 97, 78, 87, 92); 
   total := names.count; 
   dbms_output.put_line('Total '|| total || ' Students'); 
   FOR i in 1 .. total LOOP 
      dbms_output.put_line('Student: ' || names(i) || ' 
      Marks: ' || marks(i)); 
   END LOOP; 
END; 
/


SELECT name FROM customers ORDER BY name OFFSET 0 ROWS FETCH NEXT 5 ROWS ONLY;



DECLARE 
   CURSOR c_customers is 
   SELECT name FROM customers ORDER BY name OFFSET 0 ROWS FETCH NEXT 5 ROWS ONLY;
   type c_list is varray (6) of customers.name%type; 
   name_list c_list := c_list(); 
   counter integer :=0; 
BEGIN 
   FOR n IN c_customers LOOP 
      counter := counter + 1; 
      name_list.extend; 
      name_list(counter)  := n.name; 
      dbms_output.put_line('Customer('||counter ||'):'||name_list(counter)); 
   END LOOP; 
END; 
/ 



An index-by table (also called an associative array) is a set of key-value pairs. 


DECLARE 
   TYPE salary IS TABLE OF NUMBER INDEX BY VARCHAR2(20); 
   salary_list salary; 
   name   VARCHAR2(20); 
BEGIN 
   -- adding elements to the table 
   salary_list('A123') := 62000; 
   salary_list('D321') := 75000; 
   salary_list('B456') := 100000; 
   salary_list('E654') := 78000;  
   -- printing the table 
   name := salary_list.FIRST; 
   WHILE name IS NOT null LOOP 
      dbms_output.put_line 
      ('Salary of ' || name || ' is ' || TO_CHAR(salary_list(name))); 
      name := salary_list.NEXT(name); 
   END LOOP; 
END; 
/


DECLARE 
   CURSOR c_customers is 
      SELECT name FROM customers ORDER BY name OFFSET 0 ROWS FETCH NEXT 5 ROWS ONLY; 
   TYPE c_list IS TABLE of customers.Name%type INDEX BY binary_integer; 
   name_list c_list; 
   counter integer :=0; 
BEGIN 
   FOR n IN c_customers LOOP 
      counter := counter +1; 
      name_list(counter) := n.name; 
      dbms_output.put_line('Customer('||counter||'):'||name_list(counter)); 
   END LOOP; 
END; 
/ 





Collection Methods

EXISTS(n)
Returns TRUE if the nth element in a collection exists; otherwise returns FALSE.
COUNT
Returns the number of elements that a collection currently contains.
LIMIT
Checks the maximum size of a collection.
FIRST
Returns the first (smallest) index numbers in a collection that uses the integer subscripts.
LAST
Returns the last (largest) index numbers in a collection that uses the integer subscripts.
PRIOR(n)
Returns the index number that precedes index n in a collection.
NEXT(n)
Returns the index number that succeeds index n.
EXTEND
Appends one null element to a collection.
EXTEND(n)
Appends n null elements to a collection.
EXTEND(n,i)
Appends n copies of the ith element to a collection.
TRIM
Removes one element from the end of a collection.
TRIM(n)
Removes n elements from the end of a collection.
DELETE
Removes all elements from a collection, setting COUNT to 0.
DELETE(n)
Removes the nth element from an associative array with a numeric key or a nested table. If the associative array has a string key, the element corresponding to the key value is deleted. If n is null, DELETE(n) does nothing.
DELETE(m,n)
Removes all elements in the range m..n from an associative array or nested table. If m is larger than n or if m or n is null, DELETE(m,n) does nothing.





https://docs.oracle.com/en/database/oracle/oracle-database/23/lnpls/predefined-exceptions.html




PL/SQL Exception message consists of three parts. 
1) Type of Exception
2) An Error Code
3) A message


DECLARE 
		Declaration section 
BEGIN 
		Exception section 
EXCEPTION 
WHEN ex_name1 THEN -Error handling statements 
WHEN ex_name2 THEN -Error handling statements 
WHEN Others THEN -Error handling statements 
END;


There are 3 types of Exceptions. 
a) Named System Exceptions 
b) Unnamed System Exceptions 
c) User-defined Exceptions



DECLARE 
	c_id customers.id%type := 8; 
	c_name customers.name%type; 
	c_addr customers.address%type; 
BEGIN 
	SELECT name, address INTO c_name, c_addr FROM customers WHERE id = c_id; 
	DBMS_OUTPUT.PUT_LINE ('Name: '|| c_name); DBMS_OUTPUT.PUT_LINE ('Address: ' || c_addr); 
EXCEPTION 
	WHEN no_data_found THEN 
        dbms_output.put_line('No such customer!'); 
	WHEN others THEN dbms_output.put_line('Error!');
 END;
 /





create table product(product_id number primary key, product_desc varchar2(100));
create table product_rates(product_id number, rate number(5,2), foreign key(product_id) references product(product_id));

insert into product values(100, 'Toys');
insert into product values(104, 'books');

insert into product_rates values(100, 20);
insert into product_rates values(104, 70);

delete from product;


Error report -
ORA-02292: integrity constraint (MONICA.SYS_C007467) violated - child record found





DECLARE 
	Child_rec_exception EXCEPTION;
 	PRAGMA EXCEPTION_INIT (Child_rec_exception, -2292); 
BEGIN 
	Delete FROM product where product_id= 104;
EXCEPTION 
	WHEN Child_rec_exception THEN 
	Dbms_output.put_line('Child records are present for this product_id.');
END; 
/





DECLARE 
	exception_name EXCEPTION; 
BEGIN 
	IF condition THEN 
	RAISE exception_name;
 	END IF; 
EXCEPTION 
	WHEN exception_name THEN statement; 
END;



DECLARE 
  v_did NUMBER := 500;
  v_dname VARCHAR2(20) := 'Testing';
  e_exp_dept EXCEPTION;
BEGIN
  UPDATE departments
  SET department_name = v_dname
  WHERE department_name = v_dname;
  IF SQL%NOTFOUND THEN
    RAISE e_exp_dept;
  END IF;
  COMMIT;
EXCEPTION
WHEN e_exp_dept THEN
  DBMS_OUTPUT.PUT_LINE('No such department id.');
END;
/



CREATE [OR REPLACE] PROCEDURE procedure_name [ (parameter [,parameter]) ] 
IS 
[declaration_section]
 BEGIN 
executable_section
 [EXCEPTION exception_section] 
END [procedure_name];




CREATE OR REPLACE PROCEDURE greetings
 AS
 BEGIN 
dbms_output.put_line('Hello World!');
 END;
 /




EXECUTE greetings;



BEGIN 
greetings; 
END; 
/






















































